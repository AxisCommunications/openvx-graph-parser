<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>graph_parser.graphml_parser</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="graph_parser-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="graph_parser-module.html">Package&nbsp;graph_parser</a> ::
        Package&nbsp;graphml_parser
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
        <tr><td align="right"><span class="options">[<a href="javascript:void(0);" class="privatelink"
    onclick="toggle_private();">hide&nbsp;private</a>]</span></td></tr>
        <tr><td align="right"><span class="options"
            >[<a href="frames.html" target="_top">frames</a
            >]&nbsp;|&nbsp;<a href="graph_parser.graphml_parser-module.html"
            target="_top">no&nbsp;frames</a>]</span></td></tr>
      </table>
    </td>
  </tr>
</table>
<!-- ==================== PACKAGE DESCRIPTION ==================== -->
<h1 class="epydoc">Package graphml_parser</h1><p class="nomargin-top"><span class="codelink"><a href="graph_parser.graphml_parser-pysrc.html">source&nbsp;code</a></span></p>
<p>Graph parser package for parsing OpenVX graphs saved in the yEd 
  graphml format</p>
  <h1 class="heading">Introduction</h1>
    <p>The yEd graph is expected to contain parser-specific node data for 
    how to set up the autogenerated OpenVX C-code that handles creating 
    graph skeletons and switching I/O images.</p>
    <p>In order for the parser to understand how to generate the graph 
    source code correctly, a few instructions need to be followed.</p>
    <h2 class="heading">Where to add metadata information to nodes</h2>
      <p>To add parameters or other information to any nodes (function 
      nodes and image nodes), right click on the node, and select 
      &quot;Properties&quot;. Select the &quot;Data&quot; tab and enter the
      needed data in the &quot;Description&quot; field. All additional 
      information needed to process nodes is added here except if settings 
      that are global for the whole graph. (see the UserData object for 
      this exception).</p>
      <p>Parameter information in the Data field is given within square 
      brackets, first specifying the type of information given (nodetype, 
      vx_df_image_e etc.), and after space separation, giving the value of 
      that parameter (e.g. input_image[3] or VX_DF_IMAGE_U8, DYNAMIC 
      etc.).</p>
      <p>Note that if parameters have been added to the Data field of a 
      node, one can see them as a popup if one hovers with the mouse 
      pointer over that node in the yEd editor. If no parameters have been 
      added, the popup only displays the name of the node.</p>
    <h2 class="heading">Adding a function node to the graph</h2>
      <ol start="1">
        <li>
          Function nodes should be flowchart objects of type 
          &quot;Start1&quot; or &quot;Start2&quot; (choose the one that 
          fits the diagram best visually)
        </li>
        <li>
          The function nodes should be named after the OpenVX function they
          represent, but omitting the &quot;vx&quot; and the 
          &quot;Node&quot; part of the node name. E.g. for the function 
          node named  &quot;vxHalfScaleGaussianNode&quot; in the standard, 
          one should name the function node 
          &quot;HalfScaleGaussianNode&quot;. The name is added to the text 
          field of the node. The reason to omit the &quot;vx&quot; and 
          &quot;Node&quot; parts is to make names in the graph shorter and 
          easier to read.
        </li>
        <li>
          We also need to add (to the &quot;Data&quot; tab) any needed 
          parameters as specified in the OpenVX standard. They are added 
          with square brackets in the same way as for image nodes. For 
          instance, for vxHalfScaleGaussion the OpenVX standard requires 
          the parameter &quot;vx_int32 kernel_size&quot;. We follow that 
          notation and add the information in the Data field of the 
          function node: [vx_int32 5], for a kernel size of 5 pixels.
        </li>
        <li>
          By writing a <i>dynamic_type</i> followed by a type name within 
          square brackets, (e.g. [dynamic_type vx_int32[index]]) the python
          parser interprets <i>dynamic_type</i> as a directive to the 
          parser to treat the named type as a dynamic parameter whose value
          can be changed between graph executions. Indexing should start 
          from 0 and have no &quot;gaps&quot;. One can still provide an 
          initial value directly in the graph data tab however. The 
          parameter is changed at runtime by using the graphmanager 
          function <i>graphmanager_set_graph_parameter_by_index</i>. The 
          indexing when using this function should be the same as the 
          indexing that was used in yEd. See the graphmanager documentation
          for further details. Note that, except the image parameters, the 
          supported nodes currently never has 2 parameters of the same 
          type, so this notation is currently unambiguous. Should there be 
          a need to support multiple parameters of the same type in a 
          single node, the parser would need to be updated to handle this. 
          Note also that enums should use the specific type and not the 
          generic wrapper name.
          <p>E.g. the API for vxConvertDepthNode specifies that the 
          parameter &quot;policy&quot; should be of type 
          &quot;vx_enum&quot;. However, as is specified in the parameter 
          description, &quot;vx_enum&quot; should be of the specific type 
          &quot;vx_convert_policy_e&quot;. The graph parser is designed to 
          look for the specific type, and not the generic 
          &quot;vx_enum&quot; type.</p>
        </li>
      </ol>
    <h2 class="heading">Adding an image node to the graph</h2>
      <ol start="1">
        <li>
          Image data nodes should be the flowchart object type 
          &quot;Process&quot;
        </li>
        <li>
          For image nodes that are input nodes or output nodes, we need to 
          add (to the &quot;Data&quot; tab) the node type and assign an 
          array index in the corresponding image array, e.g. [nodetype 
          input_image[3]] for an input image that is accessed with 
          input_images[3]. Indexing should start from 0 and have no 
          &quot;gaps&quot;. We also need to add the image format, e.g. 
          [vx_df_image_e VX_DF_IMAGE_U8], to the data tab. If no nodetype 
          is added, the image node will be a virtual image, and the image 
          type will be VX_DF_IMAGE_VIRT, which means the OpenVX framework 
          can decide by itself what image format it should have. (A 
          technical detail is that before the parser generates the C-code 
          it checks that all image formats are consistent throughout the 
          graph, and since it has the explicit information, it will 
          actually never use the image format VX_DF_IMAGE_VIRT, but instead
          use the image format it found that the OpenVX framework will have
          to use. However, note that the image node type in this case is 
          still a virtual image.)
        </li>
      </ol>
      <p>See the documentation of the graph manager for information on how 
      to set I/O images when using the graph in algorithm code.</p>
    <h2 class="heading">Connecting nodes in the graph</h2>
      <ol start="1">
        <li>
          The edges (the lines between nodes) should have a target arrow, 
          since we are working with directed graphs, The type is arbitrary 
          (one can choose the ones that give the best visual appearance, 
          e.g. quadratic, Bezier, polyline etc.)
        </li>
        <li>
          If a function node has 2 input or 2 output edges, they need to be
          labeled so that the parser can know which edge corresponds to 
          which parameter index in the OpenVX API. To add a label to an 
          edge, right-click on the edge and choose &quot;Add label&quot;. 
          The 2 input edges should be labeled &quot;in1&quot; and 
          &quot;in2&quot; respectively (note, no spacing or capital 
          letters) The 2 output edges should be labeled &quot;out1&quot; 
          and &quot;out2&quot; respectively. Note that for single input or 
          output edges, no labeling is needed.
        </li>
      </ol>
    <h2 class="heading">Userdata objects</h2>
      <p>This object should be of the type &quot;User Message&quot; (with 
      an arrow-like right border). It should not be connected to any other 
      object in the graph. Furthermore, it is an optional object, and there
      should be at most one such object per graph (or subgraph).</p>
      <p>To set userdata parameters, right-click on the node and choose 
      &quot;Properties&quot; and the &quot;Data&quot; tab. Enter any 
      parameters that are global for the whole graph.</p>
      <p>The value of such parameters can then be set by the user of the 
      graph when the graph is registered to the graph manager, by passing 
      in a UserData parameter object. For instance, if a reference width is
      needed to be specified, one can add the parameter [unsigned 
      ref_width] to the UserData object.</p>
      <p>See the documentation of the graph manager for further information
      on how to set the userdata parameter when registering the graph in 
      the algorithm code.</p>
    <h2 class="heading">Debug image nodes</h2>
      <p>These nodes are primarily intended to be used during the design 
      phase when a calculation graph is constructed and tested e.g. for 
      bitexactness. It allows for the intermediate image data to be saved 
      to external memory buffers that can be used for testing of the 
      algorithm. They are typically removed before the production code is 
      released.</p>
      <p>Debug nodes should have the following information in the data 
      tab:</p>
      <ol start="1">
        <li>
          An image debug node type should be specified, i.e. [nodetype 
          debug_image[index]]. Note that it must be indexed, and indexing 
          should start from 0 and have no &quot;gaps&quot;.
        </li>
        <li>
          The debug node image format, e.g. [vx_df_image_e VX_DF_IMAGE_U8].
          Since this is a node with an externally accessed memory buffer, 
          it can not be of type VX_DF_IMAGE_VIRT.
        </li>
      </ol>
      <p>See the documentation of the graph manager for information on how 
      to set debug images when using the registered graph in algorithm 
      code.</p>
    <h2 class="heading">Subgraphs</h2>
      <p>The graph manager object allows for &quot;chaining&quot; of 
      graphs, where each graph drawn in yEd can be treated as a subgraph. 
      This is useful for e.g. graphs with repetitive patterns. The chaining
      is done during registration time, Therefore nothing needs to be done 
      in yEd in order to later use a particular graph as a subgraph.</p>
      <p>See the graphmanager documentation for further details on how to 
      use chaining of subgraphs.</p>
    <h2 class="heading">TODO</h2>
      <p>The format of the metadata information for nodes is currently 
      compatible with OpenVX1.0.1. It should be updated to OpenVX1.1.</p>
      <p>For example a border mode can be specified as [vx_border_mode_e 
      VX_BORDER_MODE_CONSTANT] which for OpenVX1.1 would be [vx_border_e 
      VX_BORDER_CONSTANT].</p>
      <p>The code generator will still produce OpenVX code for 1.1 but we 
      should still keep the graph format updated. This has not been done 
      yet due to lack of time.</p>

<!-- ==================== SUBMODULES ==================== -->
<a name="section-Submodules"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td colspan="2" class="table-header">
    <table border="0" cellpadding="0" cellspacing="0" width="100%">
      <tr valign="top">
        <td align="left"><span class="table-header">Submodules</span></td>
        <td align="right" valign="top"
         ><span class="options">[<a href="#section-Submodules"
         class="privatelink" onclick="toggle_private();"
         >hide private</a>]</span></td>
      </tr>
    </table>
  </td>
</tr>
  <tr><td class="summary">
  <ul class="nomargin">
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.function_nodes-module.html">graph_parser.graphml_parser.function_nodes</a></strong>: <em class="summary">Function Nodes Class</em>    </li>
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.graphml_parser-module.html">graph_parser.graphml_parser.graphml_parser</a></strong>: <em class="summary">Parser class for parsing OpenVX graphs saved in the yEd graphml 
        format</em>    </li>
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.image_format_checker-module.html">graph_parser.graphml_parser.image_format_checker</a></strong>: <em class="summary">Image Format Checker Class</em>    </li>
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.image_nodes-module.html">graph_parser.graphml_parser.image_nodes</a></strong>: <em class="summary">Image Nodes class</em>    </li>
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.parse_common-module.html">graph_parser.graphml_parser.parse_common</a></strong>: <em class="summary">Common node-related functions</em>    </li>
    <li> <strong class="uidlink"><a href="graph_parser.graphml_parser.userdata-module.html">graph_parser.graphml_parser.userdata</a></strong>: <em class="summary">Userdata class</em>    </li>
  </ul></td></tr>
</table>

<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="graph_parser-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1
    on Fri May 10 09:14:19 2019
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
